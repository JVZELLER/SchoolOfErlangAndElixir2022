# Exercises

## FizzBuzz

Write a function that returns the numbers from 1 to `n`.
But for multiples of:

* three replaces a number with an atom `:fizz` instead of the number
* five replaces a number with an atom `:buzz`
* both three and five replaces a number with an atom `:fizzbuzz`.

Tip: see [How to use `div/2` and/or `rem/2`?](https://elixir-lang.org/getting-started/basic-types.html#basic-arithmetic)

```elixir
defmodule FizzBuzz do
  def fizzbuzz(0), do: []

  def fizzbuzz(n) do
    1..n
    |> Enum.to_list()
    |> Enum.map(fn
      num when rem(num, 15) == 0 -> :fizzbuzz
      num when rem(num, 5) == 0 -> :buzz
      num when rem(num, 3) == 0 -> :fizz
      num -> num
    end)
  end
end
```

```elixir
[] = FizzBuzz.fizzbuzz(0)
[1] = FizzBuzz.fizzbuzz(1)
[1, 2] = FizzBuzz.fizzbuzz(2)
[1, 2, :fizz] = FizzBuzz.fizzbuzz(3)

[
  1,
  2,
  :fizz,
  4,
  :buzz,
  :fizz,
  7,
  8,
  :fizz,
  :buzz,
  11,
  :fizz,
  13,
  14,
  :fizzbuzz,
  16,
  17,
  :fizz,
  19,
  :buzz,
  :fizz,
  22,
  23,
  :fizz,
  :buzz,
  26,
  :fizz,
  28,
  29,
  :fizzbuzz,
  31
] = FizzBuzz.fizzbuzz(31)
```

## Quick sort

If list is empty (or 1 element) list it is sorted.
Pick the first element of a list `fisrt`.
Filer smaller elements from the the first element `first` of a remaining list to a list `smaller`.
Filer greater or equal elements from the the first element `first` of a remaining list filter to a list `bigger`.
Sort `smaller` to `sorted_smaller`.
Sort `bigger` to `sorted_bigger`.
Return `sorted_smaller ++ [first] ++ sorted_bigger`.
Tip: use [`Enum.filter/2`](https://elixirschool.com/en/lessons/basics/enum/#filter).

```elixir
defmodule QuickSort do
  def quicksort([]), do: []
  def quicksort([x]), do: [x]

  def quicksort([current | rest]) do
    sorted_smaller =
      rest
      |> Enum.filter(&(&1 < current))
      |> quicksort()

    sorted_bigger_or_equil =
      rest
      |> Enum.filter(&(&1 >= current))
      |> quicksort()

    sorted_smaller ++ [current] ++ sorted_bigger_or_equil
  end
end
```

```elixir
[] = QuickSort.quicksort([])
[1] = QuickSort.quicksort([1])
[1, 2] = QuickSort.quicksort([1, 2])
[1, 2] = QuickSort.quicksort([2, 1])
```

```elixir
ExUnit.start(autorun: false)

defmodule QuickSort.Test do
  use ExUnit.Case, async: false

  test "Empty list is sorted" do
    assert [] == QuickSort.quicksort([])
  end

  test "single element list is sorted" do
    assert [1] == QuickSort.quicksort([1])
  end

  test "sorted 2 element list is sorted" do
    assert [1, 2] == QuickSort.quicksort([1, 2])
  end

  test "unsorted 2 element list gets sorted" do
    assert [1, 2] == QuickSort.quicksort([2, 1])
  end

  test "repeated element does not disappear" do
    assert [3, 3, 3] == QuickSort.quicksort([3, 3, 3])
  end

  test "comperative implementation check" do
    len = :rand.uniform(100_000)

    lst =
      1..len
      |> Enum.to_list()
      |> Enum.map(fn _ -> :rand.uniform(100_000) - 50_000 end)

    expected = Enum.sort(lst)
    actuall = QuickSort.quicksort(lst)
    assert expected == actuall
  end
end

ExUnit.run()
```

## Wordle

Wordle is such a simple game that there are hardly any rules. But here you go:

* You have to guess the Wordle in six goes or less
* Every word you enter must be in the word list.
* A correct letter turns green.
* A correct letter in the wrong place turns yellow[*](https://nerdschalk.com/wordle-same-letter-twice-rules-explained-how-does-it-work/).
* An incorrect letter turns gray.
* Letters can be used more than once.
* Word consists of 5 letters.

Rules taken form [here](https://www.tomsguide.com/news/what-is-wordle).

Implement a function that takes two 5 letters words (the one that needs to be guessed and your guess) and returnes
a list of colors for each letter.

Tip:

```elixir
[?a, ?s, ?d, ?f] == :binary.bin_to_list("asdf")
```

```elixir
defmodule Wordle do
  def color_word(actuall, guess) do
    actuall_lst = :binary.bin_to_list(actuall)
    guess_lst = :binary.bin_to_list(guess)
    color(guess_lst, actuall_lst)
  end

  defp color(guess_lst, actuall_lst) do
    green = green(guess_lst, actuall_lst)

    actual_possibly_yellow =
      [green, actuall_lst]
      |> List.zip()
      |> Enum.filter(fn
        {:green, _} -> false
        _ -> true
      end)
      |> Enum.map(fn {_, letter} -> letter end)
      |> List.foldl(%{}, fn letter, letters_count_map ->
        old = Map.get(letters_count_map, letter, 0)
        Map.put(letters_count_map, letter, old + 1)
      end)

    yellow_or_gray(guess_lst, green, actual_possibly_yellow)
    |> Enum.map(fn {_, color} -> color end)
  end

  defp green(guess_lst, actuall_lst) do
    [guess_lst, actuall_lst]
    |> List.zip()
    |> Enum.map(fn
      {x, x} -> :green
      _ -> :not_green
    end)
  end

  defp yellow_or_gray([], _green, _actual_possibly_yellow), do: []

  defp yellow_or_gray([guess_hd | guess_tail], [:green | green_tail], actual_possibly_yellow) do
    [{guess_hd, :green} | yellow_or_gray(guess_tail, green_tail, actual_possibly_yellow)]
  end

  defp yellow_or_gray([guess_hd | guess_tail], [:not_green | green_tail], actual_possibly_yellow) do
    if Map.has_key?(actual_possibly_yellow, guess_hd) do
      new_actual_possibly_yellow =
        case Map.get(actual_possibly_yellow, guess_hd) do
          1 -> Map.delete(actual_possibly_yellow, guess_hd)
          n -> Map.put(actual_possibly_yellow, guess_hd, n - 1)
        end

      [
        {guess_hd, :yellow}
        | yellow_or_gray(
            guess_tail,
            green_tail,
            new_actual_possibly_yellow
          )
      ]
    else
      [
        {guess_hd, :gray}
        | yellow_or_gray(guess_tail, green_tail, actual_possibly_yellow)
      ]
    end
  end
end
```

Implement remaining tescases

```elixir
ExUnit.start(autorun: false)

defmodule Wordle.Test do
  use ExUnit.Case, async: false

  test "none of the latters match" do
    expected = [:gray, :gray, :gray, :gray, :gray]
    assert expected == Wordle.color_word("abcde", "fghij")
  end

  test "all of the latters match" do
    expected = [:green, :green, :green, :green, :green]
    assert expected == Wordle.color_word("abcde", "abcde")
  end

  test "a letter is in different place" do
    expected = [:green, :gray, :gray, :gray, :gray]
    assert expected == Wordle.color_word("acccc", "abbbb")
  end

  test "a letter is passed 2 times but exists once in a word both in different place" do
    expected = [:yellow, :gray, :gray, :gray, :gray]
    assert expected == Wordle.color_word("cccac", "aabbb")
  end

  test "a letter is passed 3 times but exists once in a word all in different place" do
    expected = [:yellow, :gray, :gray, :gray, :gray]
    assert expected == Wordle.color_word("bbbbc", "cccaa")
  end

  test "a letter is passed 2 times but exists once in a word and one is in the right place" do
    expected = [:gray, :green, :gray, :gray, :gray]
    assert expected == Wordle.color_word("abaaa", "cbbcc")
  end

  test "a letter is passed 3 times but exists 3 in a word and one is in the right place" do
    expected = [:gray, :gray, :green, :yellow, :yellow]
    assert expected == Wordle.color_word("bbbaa", "ccbbb")
  end
end

ExUnit.run()
```
